// Работа с выпадающими списками в JavaScript

// Используем тег select, и следующую конструкцию , чтобы сформировать выпадающий список


{/* <select id="select">
	<option>one</option>
	<option>two</option>
	<option>three</option>
</select>


С помощью атрибута multiple в теге select - пользователь можем выбрать несколько пунктов выпадающего списка. 

 <select multiple name="city[]">
	<option>Минск</option>
	<option>Киев</option>
	<option>Лондон</option>
</select>
<br></br> */}

// <!-- Атрибут size в теге select  позволяет установить, сколько элементов будут отображаться одномоментно в списке. Значение size="1" отображает только один элемент списка, а сам список становится выпадающим. Если установить у элемента select атрибут multiple, то в списке можно выбрать сразу несколько значений. -->


// <!-- <select size="3">
//     <option value="volvo">Volvo</option>
//     <option value="saab">Saab</option>
//     <option value="opel">Opel</option>
//     <option value="audi">Audi</option>
//   </select>

// <select id="select" size="1">
//     <option value="volvo">Volvo</option>
//     <option value="saab">Saab</option>
//     <option value="opel">Opel</option>
//     <option value="audi">Audi</option>
//   </select>  -->

//Элемент select поддерживает три события: blur (потеря фокуса), focus (получение фокуса) и change (изменение выделенного элемента в списке). 

{/* <select id="select">
	<option value="volvo">one</option>
	<option selected>two</option>
	<option>three</option>
</select>
<br></br> */}

// let select = document.querySelector('#select');
// select.addEventListener('blur', ()=>{
// 	console.log('blur');
// })
// select.addEventListener('focus', ()=>{
// 	console.log('focus');
// })
// select.addEventListener('change', ()=>{
// 	console.log('change');
// })


//В каждый объект HtmlOptionElement имеет свойства: index (индекс в коллекции options), text (отображаемый текст) и value (значение элемента). , а в свойстве selected - значение true или false в зависимости от того, выбранный пункт списка или нет:

// let select = document.querySelector('#select');
// let option = select[0];
// console.log(option.index);
// console.log(option.text);
// console.log(option.value);
// console.log(option.selected);


//Атрибут selected в теге option,  позволяет задать выбранный пункт по умолчанию, если мы используем атрибут multiple в теге select можем выбрать несколько пунктов option,

//Любому тегу option можно установить свойство selected в значении true.
// let select = document.querySelector('#select');
// let option = select[2];
// option.selected = true;
// console.log(select.selectedIndex);

//свойство selectedIndex, хранящее в себе номер того пункта списка, который сейчас выбран. Нумерация при этом начинается с нуля.

//можно получить выбранный тег option следующим образом:
// let select = document.querySelector('#select');
// console.log(select[select.selectedIndex]);


{/* <select id="select">
	<option>one</option>

	<option selected>two</option>
	<option>three</option>
</select> */}


{/* <select multiple name="city[]">
	<option>Москва - столица России</option>
	<option selected>Минск</option>
	<option>Киев</option>
	<option selected>Лондон</option>
</select> */}

// Тег optgroup группирует пункты option выпадающего списка select.
// Тег label Задает текст, который будет заголовком для группы пунктов списка.


// <!-- <select>
// 	<optgroup label="Города Украины">
// 		<option>Киев</option>
// 		<option>Харьков</option>
// 	</optgroup>
// 	<optgroup label="Города Беларуси">
// 		<option>Минск</option>
// 		<option>Витебск</option>
// 	</optgroup>
// </select> -->

// как нам получить все пункты этого списка? 

// let select = document.querySelector('#select');
// console.log(document.querySelectorAll('#select option'));
// // или конкретно в нашем селекте
// console.log(select.querySelectorAll('option'));
// //переменную можно перебрать циклом:
// for (let option of select) {
// 	console.log(option);
// }
// // Ну или просто обратится к пункту с нужным номером:
// console.log(select[0]);

Работа с выпадающими списками в JavaScript
//Тег datalist
//С данным элементом можно использовать все глобальные атрибуты.


{/* <input type="text" list="country" autocomplete="on" id="select2">
<datalist id="country">
	<option>Беларусь</option>
	<option>Бельгия</option>
	<option>Болгария</option>
</datalist> */}

//Данная конструкция Создает список вариантов, которые можно выбирать при наборе в текстовом поле тега input. Изначально этот список скрыт и становится доступным при получении полем фокуса или наборе текста.


//Чтобы привязать список вариантов к элементу input, добавьте атрибут list для input и атрибут id с таким же значением для <datalist>. Вот пример:

{/* <input list="ice-cream-flavors"/>
<datalist id="ice-cream-flavors"></datalist>

Во всех браузерах есть механизм запоминания введенного пользователем текста, который затем используется для автодополнения.

С помощью атрибута autocomplete в теге input контролировать то, как браузер автоматически заполняет пользовательские данные. В следующем примере представлены его возможные значения:
<input type="text" name="address" autocomplete="on">
<!--
  Состояние «on» значит, что браузер может запоминать значения для дальнейшего 
  использования, а также предлагать пользователю сохранённые значения.
  -->

  <input type="text" name="secret" autocomplete="off"></input>
  <!--
  Состояние «off» приказывает браузеру не сохранять введённые значения для этого 
  input и не предлагать ранее сохранённые значения. 
  -->


В чем же основны отличия <select> и  <datalist>
<select>
<datalist>
Пользователь может выбрать только один вариант из данного списка.	
Пользователь может выбрать любой вариант из данного списка, но также может использовать свой собственный ввод.


Этот тег является типом ввода формы.	
Этот тег не является типом ввода формы.


Пользователь должен просмотреть длинный список, чтобы выбрать вариант. 	
Пользователь может легко ввести параметр и получить подсказки, а затем может быть выбран пользователем.

Пользователь может быть ограничен списком опций.	
Пользователь не ограничен списком опций.

Он не предоставляет функцию автозаполнения.	
Он обеспечивает функцию автозаполнения. */} */}




// let sel1 = document.querySelector('#select1')
// let sel2 = document.querySelector('#select2')

// sel1.addEventListener('change',()=>{
// 	console.log('sel1')
// })

// sel2.addEventListener('change',()=>{
// 	console.log('sel2')
// })

//<label for="donation">Размер пожертвования (USD):</label>
{/* <input type="range" name="donation" id="donation" list="donation_list"
  step="5" min="5" max="200">
<datalist id="donation_list">
  <option>25</option>
  <option>50</option>
  <option>100</option>
  <option>200</option>
</datalist> */}




Привязывание контекста через методы в JavaScript
– потеря this.

let user = {
	firstName: "Вася",
	sayHi() {
	  alert(`Привет, ${this.firstName}!`);
	}
  };
  
  setTimeout(user.sayHi, 1000); // Привет, undefined!
  setTimeout получил функцию sayHi отдельно от объекта user (именно здесь функция и потеряла контекст).

Как решить эту потерю.




1: сделать функцию-обёртку
Необходимо обернуть вызов в анонимную функцию, создав замыкание

setTimeout(user.sayHi, 1000); // Привет, undefined!

setTimeout(function() {
	user.sayHi(); // Привет, Вася!
  }, 1000);

setTimeout(() => user.sayHi(), 1000); // Привет, Вася! 



Метод call.
мы просто вызовем нашу функцию, сказав ей, что this равен elem.
Это делается вот так: 
func.call(elem). 

Этот код эквивалентен простому вызову функции func вот так: func(), только с условием, что this равен elem.
Итак, синтаксис метода call такой: 
функция.call(объект, который записать в this). 

Давайте соберем все вместе:
let elem = document.querySelector('#elem');
function func() {
	console.log(this.value); // выведет value инпута
}
func.call(elem);



Метод call с параметрами
Пусть теперь функция func принимает некоторые параметры, назовем их param1 и param2:

function func(param1, param2) {
	console.log(this.value + param1 + param2);
}

При вызове функции через call можно передать эти параметры вот так:

func.call(elem, param1, param2);


Метод apply в JavaScript
Он работает практически так же, как и метод call. Разница заключается в том, что в apply параметры передаются в виде массива, а не перечисляются через запятую. В зависимости от задачи бывает удобен то один, то другой метод.
Вот пример передачи параметров в метод apply:
func.apply(elem, [param1, param2]);




2: метод bind

Следующий метод bind позволяет навсегда привязать контекст к функции. Своим результатом 

этот метод возвращает новую функцию, внутри которой this будет иметь жестко заданное значение.

Давайте с помощью bind сделаем новую функцию, которая будет копией функции func, но this в ней всегда будет равен elem:
function func(param1, param2) {
	console.log(this.value + param1 + param2);
}
let newFunc = func.bind(elem);
Теперь в переменной newFunc лежит функция. Давайте вызовем ее, передав в первый параметр '1', а во второй '2' (напоминаю, что в elem лежит инпут с value, равным 'text'):
newFunc('1', '2');

Не обязательно записывать результат работы bind в новую функцию newFunc, можно просто перезаписать func. После этого func будет такой же функцией, как и была, но с жестко связанным this:

func = func.bind(elem);




let boundFunc = func.bind(context);
вызов в func, при этом устанавливая this=context.

let user = {
	firstName: "Вася"
  };
  
  function func() {
	alert(this.firstName);
  }
  
  let funcUser = func.bind(user);
  funcUser(); // Вася





Мы можем привязать не только this, но и аргументы. - такая функция называется «частично применённой» или «частичной».
let bound = func.bind(context, [arg1], [arg2], ...);
Это позволяет привязать контекст this и начальные аргументы функции.

function mul(a, b) {
	return a * b;
  }
  
  let triple = mul.bind(null, 3);
  
  alert( triple(3) ); // = mul(3, 3) = 9


  Удобный метод: bindAll
  Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:
  
  for (let key in user) {
	if (typeof user[key] == 'function') {
	  user[key] = user[key].bind(user);
	}
  }



замыкание

Это функция внутри другой функции

Функция которая будет возвращать функцию;


Плюсы
позволяет аккуратно писать код
не замарачиваться с переменными








