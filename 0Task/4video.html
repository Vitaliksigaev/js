// Работа с выпадающими списками в JavaScript

// Используем тег select, и следующую конструкцию , чтобы сформировать выпадающий список


{/* <select id="select">
	<option>one</option>
	<option>two</option>
	<option>three</option>
</select>


С помощью атрибута multiple в теге select - пользователь можем выбрать несколько пунктов выпадающего списка. 

 <select multiple name="city[]">
	<option>Минск</option>
	<option>Киев</option>
	<option>Лондон</option>
</select>
<br></br> */}

// <!-- Атрибут size в теге select  позволяет установить, сколько элементов будут отображаться одномоментно в списке. Значение size="1" отображает только один элемент списка, а сам список становится выпадающим. Если установить у элемента select атрибут multiple, то в списке можно выбрать сразу несколько значений. -->


// <!-- <select size="3">
//     <option value="volvo">Volvo</option>
//     <option value="saab">Saab</option>
//     <option value="opel">Opel</option>
//     <option value="audi">Audi</option>
//   </select>

// <select id="select" size="1">
//     <option value="volvo">Volvo</option>
//     <option value="saab">Saab</option>
//     <option value="opel">Opel</option>
//     <option value="audi">Audi</option>
//   </select>  -->

//Элемент select поддерживает три события: blur (потеря фокуса), focus (получение фокуса) и change (изменение выделенного элемента в списке). 

{/* <select id="select">
	<option value="volvo">one</option>
	<option selected>two</option>
	<option>three</option>
</select>
<br></br> */}

// let select = document.querySelector('#select');
// select.addEventListener('blur', ()=>{
// 	console.log('blur');
// })
// select.addEventListener('focus', ()=>{
// 	console.log('focus');
// })
// select.addEventListener('change', ()=>{
// 	console.log('change');
// })


//В каждый объект HtmlOptionElement имеет свойства: index (индекс в коллекции options), text (отображаемый текст) и value (значение элемента). , а в свойстве selected - значение true или false в зависимости от того, выбранный пункт списка или нет:

// let select = document.querySelector('#select');
// let option = select[0];
// console.log(option.index);
// console.log(option.text);
// console.log(option.value);
// console.log(option.selected);


//Атрибут selected в теге option,  позволяет задать выбранный пункт по умолчанию, если мы используем атрибут multiple в теге select можем выбрать несколько пунктов option,

//Любому тегу option можно установить свойство selected в значении true.
// let select = document.querySelector('#select');
// let option = select[2];
// option.selected = true;
// console.log(select.selectedIndex);

//свойство selectedIndex, хранящее в себе номер того пункта списка, который сейчас выбран. Нумерация при этом начинается с нуля.

//можно получить выбранный тег option следующим образом:
// let select = document.querySelector('#select');
// console.log(select[select.selectedIndex]);


{/* <select id="select">
	<option>one</option>

	<option selected>two</option>
	<option>three</option>
</select> */}


{/* <select multiple name="city[]">
	<option>Москва - столица России</option>
	<option selected>Минск</option>
	<option>Киев</option>
	<option selected>Лондон</option>
</select> */}

// Тег optgroup группирует пункты option выпадающего списка select.
// Тег label Задает текст, который будет заголовком для группы пунктов списка.


// <!-- <select>
// 	<optgroup label="Города Украины">
// 		<option>Киев</option>
// 		<option>Харьков</option>
// 	</optgroup>
// 	<optgroup label="Города Беларуси">
// 		<option>Минск</option>
// 		<option>Витебск</option>
// 	</optgroup>
// </select> -->

// как нам получить все пункты этого списка? 

// let select = document.querySelector('#select');
// console.log(document.querySelectorAll('#select option'));
// // или конкретно в нашем селекте
// console.log(select.querySelectorAll('option'));
// //переменную можно перебрать циклом:
// for (let option of select) {
// 	console.log(option);
// }
// // Ну или просто обратится к пункту с нужным номером:
// console.log(select[0]);

Работа с выпадающими списками в JavaScript
//Тег datalist
//С данным элементом можно использовать все глобальные атрибуты.


{/* <input type="text" list="country" autocomplete="on" id="select2">
<datalist id="country">
	<option>Беларусь</option>
	<option>Бельгия</option>
	<option>Болгария</option>
</datalist> */}

//Данная конструкция Создает список вариантов, которые можно выбирать при наборе в текстовом поле тега input. Изначально этот список скрыт и становится доступным при получении полем фокуса или наборе текста.


//Чтобы привязать список вариантов к элементу input, добавьте атрибут list для input и атрибут id с таким же значением для <datalist>. Вот пример:

{/* <input list="ice-cream-flavors"/>
<datalist id="ice-cream-flavors"></datalist>

Во всех браузерах есть механизм запоминания введенного пользователем текста, который затем используется для автодополнения.

С помощью атрибута autocomplete в теге input контролировать то, как браузер автоматически заполняет пользовательские данные. В следующем примере представлены его возможные значения:
<input type="text" name="address" autocomplete="on">
<!--
  Состояние «on» значит, что браузер может запоминать значения для дальнейшего 
  использования, а также предлагать пользователю сохранённые значения.
  -->

  <input type="text" name="secret" autocomplete="off"></input>
  <!--
  Состояние «off» приказывает браузеру не сохранять введённые значения для этого 
  input и не предлагать ранее сохранённые значения. 
  -->


В чем же основны отличия <select> и  <datalist>
<select>
<datalist>
Пользователь может выбрать только один вариант из данного списка.	
Пользователь может выбрать любой вариант из данного списка, но также может использовать свой собственный ввод.


Этот тег является типом ввода формы.	
Этот тег не является типом ввода формы.


Пользователь должен просмотреть длинный список, чтобы выбрать вариант. 	
Пользователь может легко ввести параметр и получить подсказки, а затем может быть выбран пользователем.

Пользователь может быть ограничен списком опций.	
Пользователь не ограничен списком опций.

Он не предоставляет функцию автозаполнения.	
Он обеспечивает функцию автозаполнения. */} */}




// let sel1 = document.querySelector('#select1')
// let sel2 = document.querySelector('#select2')

// sel1.addEventListener('change',()=>{
// 	console.log('sel1')
// })

// sel2.addEventListener('change',()=>{
// 	console.log('sel2')
// })

//<label for="donation">Размер пожертвования (USD):</label>
{/* <input type="range" name="donation" id="donation" list="donation_list"
  step="5" min="5" max="200">
<datalist id="donation_list">
  <option>25</option>
  <option>50</option>
  <option>100</option>
  <option>200</option>
</datalist> */}




Привязывание контекста через методы в JavaScript
– потеря this.

let user = {
	firstName: "Вася",
	sayHi() {
	  alert(`Привет, ${this.firstName}!`);
	}
  };
  
  setTimeout(user.sayHi, 1000); // Привет, undefined!
  setTimeout получил функцию sayHi отдельно от объекта user (именно здесь функция и потеряла контекст).

Как решить эту потерю.




1: сделать функцию-обёртку
Необходимо обернуть вызов в анонимную функцию, создав замыкание

setTimeout(user.sayHi, 1000); // Привет, undefined!

setTimeout(function() {
	user.sayHi(); // Привет, Вася!
  }, 1000);

setTimeout(() => user.sayHi(), 1000); // Привет, Вася! 



Метод call.
мы просто вызовем нашу функцию, сказав ей, что this равен elem.
Это делается вот так: 
func.call(elem). 

Этот код эквивалентен простому вызову функции func вот так: func(), только с условием, что this равен elem.
Итак, синтаксис метода call такой: 
функция.call(объект, который записать в this). 

Давайте соберем все вместе:
let elem = document.querySelector('#elem');
function func() {
	console.log(this.value); // выведет value инпута
}
func.call(elem);



Метод call с параметрами
Пусть теперь функция func принимает некоторые параметры, назовем их param1 и param2:

function func(param1, param2) {
	console.log(this.value + param1 + param2);
}

При вызове функции через call можно передать эти параметры вот так:

func.call(elem, param1, param2);


Метод apply в JavaScript
Он работает практически так же, как и метод call. Разница заключается в том, что в apply параметры передаются в виде массива, а не перечисляются через запятую. В зависимости от задачи бывает удобен то один, то другой метод.
Вот пример передачи параметров в метод apply:
func.apply(elem, [param1, param2]);




2: метод bind

Следующий метод bind позволяет навсегда привязать контекст к функции. Своим результатом 

этот метод возвращает новую функцию, внутри которой this будет иметь жестко заданное значение.

Давайте с помощью bind сделаем новую функцию, которая будет копией функции func, но this в ней всегда будет равен elem:
function func(param1, param2) {
	console.log(this.value + param1 + param2);
}
let newFunc = func.bind(elem);
Теперь в переменной newFunc лежит функция. Давайте вызовем ее, передав в первый параметр '1', а во второй '2' (напоминаю, что в elem лежит инпут с value, равным 'text'):
newFunc('1', '2');

Не обязательно записывать результат работы bind в новую функцию newFunc, можно просто перезаписать func. После этого func будет такой же функцией, как и была, но с жестко связанным this:

func = func.bind(elem);




let boundFunc = func.bind(context);
вызов в func, при этом устанавливая this=context.

let user = {
	firstName: "Вася"
  };
  
  function func() {
	alert(this.firstName);
  }
  
  let funcUser = func.bind(user);
  funcUser(); // Вася





Мы можем привязать не только this, но и аргументы. - такая функция называется «частично применённой» или «частичной».
let bound = func.bind(context, [arg1], [arg2], ...);
Это позволяет привязать контекст this и начальные аргументы функции.

function mul(a, b) {
	return a * b;
  }
  
  let triple = mul.bind(null, 3);
  
  alert( triple(3) ); // = mul(3, 3) = 9


  Удобный метод: bindAll
  Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:
  
  for (let key in user) {
	if (typeof user[key] == 'function') {
	  user[key] = user[key].bind(user);
	}
  }










Замыкание
ОЧень интересная и полезная тема, чтобы ее изучить и повторить.

Замыкание — это комбинация функции и лексического окружения (функицональная область видимости), в котором эта функция была определена. 

ТЕм самым создаются изолированные области 
где можно  выполнять один и тот же код с разными переменными


Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. 

Когда JavaScript создает функцию он запоминает ее окружение

При вызове вложенной функции происходит замыкание данных даной функции


замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.

переменные замкнуты на саму функцию.


function makeAdder(x) {
	return function(y) {
	  return x + y;
	};
  };


var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12

add5 и add10 — это примеры замыканий. Эти функции делят одно определение тела функции, но при этом они сохраняют различные окружения. В окружении функции add5 x — это 5, в то время как в окружении add10 x — это 10.

Использование этой техники увеличивает требования к производительности как в части скорости, так и в части потребления памяти.

Дополнительные примеры 

самый простой пример замыкания - это счетчик.
var counter = (function () {
  var current = 0;
  return function () {
    current++;
    return current;
  }
})();

console.log(counter()); // 1
console.log(counter()); // 2
В данном случае мы не имеем доступ к переменной current и функция гарантированно возвращает каждый раз уникальное значение.


Кнопки, которые будут менять размер текста с использованием относительных единиц em

<a href="#" id="size-12">12</a>
<a href="#" id="size-14">14</a>
<a href="#" id="size-16">16</a>


body {
	font-family: Helvetica, Arial, sans-serif;
	font-size: 12px;
  }
  
  h1 {
	font-size: 1.5em;
  }
  
  h2 {
	font-size: 1.2em;
  }


function makeSizer(size) {
	return function() {
		document.body.style.fontSize = size + 'px';
	};
};

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;


Пример 2

три подсказки для трёх полей ввода

<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email"></p>
<p>Name: <input type="text" id="name" name="name"></p>
<p>Age: <input type="text" id="age" name="age"></p>

function showHelp(help) { // генерирует вывод текста в поле подсказка
	document.getElementById('help').innerHTML = help;
  }
  
  function makeHelpCallback(help) { // функция makeHelpCallback создаёт каждому из замыканий своё собственное, в котором переменная item указывает на правильный элемент массива helpText.
	return function() {
	  showHelp(help);
	};
  }
  
  function setupHelp() {// обрабатывает входные данные + в цикле вор вешает событие на каждый импут с запуском функции. 

	var helpText = [
		{'id': 'email', 'help': 'Ваш адрес e-mail'},
		{'id': 'name', 'help': 'Ваше полное имя'},
		{'id': 'age', 'help': 'Ваш возраст (Вам должно быть больше 16)'}
	  ];
  
	for (var i = 0; i < helpText.length; i++) {
	  var item = helpText[i];
	  document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
	}
  }
  
  setupHelp();




  Практика на таймеры и работу с DOM в JavaScript

  https://code.mu/ru/javascript/book/prime/timers/practicum/
  https://learn.javascript.ru/settimeout-setinterval
  https://learn.javascript.ru/settimeout-setinterval


<!-- 1 -->
<!-- <button id="start">start</button>
<p>10</p> -->
//1 Дана кнопка. Дан абзац, текстом которого является число. По нажатию на кнопку запустите таймер, который каждую секунду будет увеличивать текст абзаца на 1.
// let btn = document.querySelector('#start');
// let p = document.querySelector('p');
// btn.addEventListener('click', function() {
// 	setInterval(function(self) { 
// })



<!-- 2 -->
<!-- <button id="start">start</button>
<p>10</p> -->
//2 Дана кнопка. Дан абзац, текстом которого является число, например, 10. По нажатию на кнопку запустите таймер, который каждую секунду будет уменьшать текст абзаца на 1. Как только значение абзаца станет равно нулю - остановите таймер.
// let btn = document.querySelector('#start');
// let p = document.querySelector('p');
// btn.addEventListener('click', function() {
// 	setInterval(function(self) { 

// })


//3 Дан инпут с числом. Сделайте так, чтобы каждую секунду в нем появлялся квадрат того числа, которое в нем записано.
<!-- 3 -->
<!-- <input type="button" id="elem" value="2"> -->
// let elem = document.querySelector('#elem');
// elem.addEventListener('click', function() {
// 	setInterval(function(self) { 
// });



<!-- 4 -->
<!-- <input type="text" id="elem" value="10">
<p></p> -->
//4 Дан инпут. В него вводится число. По потери фокуса сделайте так, чтобы в абзаце ниже начал тикать обратный отсчет, начиная с введенного числа. Когда отсчет дойдет до нуля - он должен закончится.

// let elem = document.querySelector('#elem');
// let p = document.querySelector('p');
// elem.addEventListener('blur', function() {
// });

<!-- 5 -->

<!-- <input type="text" id="elem" value="5">
<button id="start">start</button>
<p>0</p> -->

//5 Дан инпут, кнопка и абзац. В инпут вводится какое-то число. По нажатию на кнопку запишите введенное число в текст абзаца и запустите обратный отсчет в абзаце: пусть каждую секунду число в абзаце уменьшается на единицу, пока не дойдет до нуля.

// let elem = document.querySelector('#elem');
// let p = document.querySelector('p');
// let btn = document.querySelector('#start');

// btn.addEventListener('click', function() {
// })


<!-- 6 -->
<!-- <p>1</p>
<button id="start1">start1</button>
<button id="start2">stop2</button> -->
//6 Дан абзац и две кнопки. Сделайте так, чтобы по нажатию на первую кнопку в абзаце начал тикать таймер от 1 до бесконечности, а по нажатию на вторую таймер останавливался.

// let p = document.querySelector('p');
// let btn1 = document.querySelector('#start1');
// let btn2 = document.querySelector('#start2');

// btn1.addEventListener('click', function() {
// })


<!-- 7 -->
<!-- <p>123456789</p> -->
// 7 Дан абзац. Сделайте так, чтобы каждую секунду он менял свой цвет с красного на зеленый и наоборот.

// let p = document.querySelector('p');
// setInterval(function() { 
// }, 1000);


<!-- 8 -->
<!-- <p></p> -->
//8 Если выводить на экран каждую секунду текущий момент времени, то можно сделать тикающие часы. Реализуйте такие же часики, как показано ниже в образце:

// let p = document.querySelector('p');
// setInterval(function() { 
// }, 1000);






setTimeout

setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

function sayHi() {
	alert('Привет');
  }
  
setTimeout(sayHi, 1000);

Задержка перед запуском в миллисекундах (1000 мс = 1 с). 
Значение по умолчанию – 0.

setInterval()
setInterval позволяет вызывать функцию регулярно, повторяя вызов с фиксированной паузой между каждым вызовом.


let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

Вызов setTimeout возвращает «идентификатор таймера» timerId, 
Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, которое возвращают методы setInterval/setTimeout.

let timerId = setTimeout(...);
clearTimeout(timerId);


Вложенный setTimeout

let delay = 5000;

let timerId = setTimeout(function request() {
  ...отправить запрос...

  if (ошибка запроса из-за перегрузки сервера) {
    // увеличить интервал для следующего запроса
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);

Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.

Вложенный setTimeout – более гибкий метод, чем setInterval. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.

Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, setTimeout(func) используется для вызовов, которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.

Например, таймер в браузере может замедляться по многим причинам:
Перегружен процессор.
Вкладка браузера в фоновом режиме.
Работа ноутбука от аккумулятора.

Задачка
Выведите в консоль число 0. Через секунду выведите число 1, через две секунды выведите число 2, через 3 секунды выведите число 3. И так далее до бесконечности.
